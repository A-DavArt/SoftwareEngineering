# Тема 8. Введение в ООП
Отчет по Теме №8 выполнил:
- Давтян Артём Артурович
- ИВТ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ |---------|---------|
| Задание 1 | +       | +       |
| Задание 2 | +       | +       |
| Задание 3 | +       | +       |
| Задание 4 | +       | +       |
| Задание 5 | +       | +       |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Создайте класс "Car" с атрибутами производитель и модель. Создайте объект этого класса. 

```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

my_car = Car("Toyota", "Corolla")
```
### Результат.

![image](https://github.com/user-attachments/assets/4b28495e-47db-4432-a0f4-f6190dfee57a)

### Выводы
Данный код демонстрирует создание класса Car, с двумя основными атрибутами: производитель (make) и модель (model).

## Лабораторная работа №2
### Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину "поехать". 

```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def drive(self):
        print(f"Driving the {self.make} {self.model}")

my_car = Car("Toyota", "Corolla")
my_car.drive()
```

### Результат.

![image](https://github.com/user-attachments/assets/446a3b94-79ea-4189-8e39-ea874ce28e68)

### Выводы
Данный код демонстрирует расширение класса Car путем добавления метода drive(), который позволяет объектам данного класса выполнять действие – "поехать". 

## Лабораторная работа №3
### Создайте новый класс "ElectricCar" с методом "charge" и атрибутом ёмкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться.

```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def drive(self):
        print(f"Driving the {self.make} {self.model}")

my_car = Car("Toyota", "Corolla")
my_car.drive()

class ElectricCar(Car):
    def __init__(self, make, model, battery_capacity):
        super().__init__(make, model)
        self.battery_capacity = battery_capacity

    def charge(self):
            print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")

my_electric_car = ElectricCar("Tesla", "Model S", 75)
my_electric_car.drive()
my_electric_car.charge()
```
### Результат.

![image](https://github.com/user-attachments/assets/66c512a2-cf4f-4fee-97f3-5b6175861c61)

### Выводы
Данный код демонстрирует создание нового класса ElectricCar, который наследует все свойства и методы базового класса Car. В классе ElectricCar добавлен атрибут battery_capacity, который хранит информацию о ёмкости батареи, и метод charge(), позволяющий имитировать процесс зарядки электромобиля.
  
## Лабораторная работа №4
### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищённый атрибут производителя и приватный атрибут модели. Вызовите защищённый атрибут и заставьте машину поехать.

```python
class Car:
    def __init__(self, make, model):
        self._make = make # Защищённый атрибут
        self.__model = model # Приватный атрибут

    def drive(self):
        print(f"Driving the {self._make} {self.__model}")

my_car = Car("Toyota", "Corolla")
print(my_car._make) # Доступ к защищённому атрибуту
my_car.drive()
```
### Результат.

![image](https://github.com/user-attachments/assets/f34ec3c1-c9d7-4f81-bc86-727de6ba5242)

### Выводы
Данный код демонстрирует реализацию инкапсуляции в классе Car через использование защищённых и приватных атрибутов. 

## Лабораторная работа №5
### Реализуйте полиморфизм, создав основной (общий) класс "Shape", а также ещё два класса "Rectangle" и "Circle". Внутри последних двух классов реализуйте методы для подсчёта площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади.

```python
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius

shapes = [
    Rectangle(5, 10),
    Circle(7)
]

for shape in shapes:
    print(f"{shape.area()}")
```
### Результат.

![image](https://github.com/user-attachments/assets/ec087b6d-e1f7-4992-83f7-dbbfdaea6ee6)

### Выводы
Данный код иллюстрирует реализацию полиморфизма в объектно-ориентированном программировании через создание общего класса Shape и его дочерних классов Rectangle и Circle.

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект.

```python
class Animal:
    def __init__(self, name, species, age):
        self.name = name
        self.species = species
        self.age = age

    def speak(self):
        return "Some sound"

dog = Animal("Rex", "Dog", 5)
print(f"{dog.name} is a {dog.species}({dog.age} y.o.)")
```
### Результат.

![image](https://github.com/user-attachments/assets/f009340d-7db2-4f4d-b7e6-f051c7476261)

### Выводы
Данный код демонстрирует создание базового класса Animal с атрибутами имени, вида и возраста, а также метод для вывода информации о животном. 
  
## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса. 

```python
class Animal:
    def __init__(self, name, species, age):
        self.name = name
        self.species = species
        self.age = age
        self.hungry = True

    def speak(self):
        return "Some sound"

    def eat(self):
        if self.hungry:
            print(f"{self.name} is eating.")
            self.hungry = False
        else:
            print(f"{self.name} is not hungry.")

cat = Animal("Barsik", "Cat", 3)
cat.eat()
cat.eat()
```
### Результат.

![image](https://github.com/user-attachments/assets/15f3aca1-abdb-44da-9632-ede46996ed5b)

### Выводы
В этом коде добавлены новые атрибуты и методы в класс Animal, что демонстрирует возможность расширения функциональности класса. Метод eat() показывает, как можно управлять состоянием животного, например, его голодом, и позволяет использовать логику внутри класса.

## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. 

```python
class Animal:
    def __init__(self, name, species, age):
        self.name = name
        self.species = species
        self.age = age
        self.hungry = True

    def speak(self):
        return "Some sound"

    def eat(self):
        if self.hungry:
            print(f"{self.name} is eating.")
            self.hungry = False
        else:
            print(f"{self.name} is not hungry.")

cat = Animal("Barsik", "Cat", 3)
cat.eat()
cat.eat()

class Dog(Animal):
    def __init__(self, name, age):
        super().__init__(name, "Dog", age)

    def speak(self):
        return "Woof!"

bulldog = Dog("Rex", 4)
print(f"{bulldog.name}({bulldog.age}) says {bulldog.speak()}")
```
### Результат.

![image](https://github.com/user-attachments/assets/1839015e-3c9e-41d0-adde-657999f8a1b3)

### Выводы
В этом коде показано, как наследование позволяет создавать специализированные классы, такие как Dog, которые используют функциональность родительского класса Animal. Это позволяет повторно использовать код и добавлять новые характеристики, такие как специфические звуки животных, реализуемые в методе speak().
  
## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом.

```python
class Animal:
    def __init__(self, name, species, age):
        self.name = name
        self.species = species
        self.__age = age

    def speak(self):
        return "Some sound"

    def get_age(self):
        return self.__age

    def set_age(self, age):
        if age > 0:
            self.__age = age

rabbit = Animal("Bunny", "Rabbit", 2)
print(f"{rabbit.name} is {rabbit.get_age()} years old.")
rabbit.set_age(3)
print(f"{rabbit.name} is now {rabbit.get_age()} years old.")
```
### Результат.

![image](https://github.com/user-attachments/assets/038f5345-9d0a-4041-8199-11adb5be0e78)

### Выводы
В данном примере была реализована инкапсуляция через использование приватных атрибутов в классе Animal. Замаскировка приватных данных (например, возраста) предоставляет контроль над доступом к этим данным и защищает их от некорректного изменения.
  
## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. 

```python
class Animal:
    def __init__(self, name, species):
        self.name = name
        self.species = species

    def speak(self):
        return "Some sound"

class Dog(Animal):
    def __init__(self, name):
        super().__init__(name, "Dog")

    def speak(self):
        return "Woof!"

class Cat(Animal):
    def __init__(self, name):
        super().__init__(name, "Cat")

    def speak(self):
        return "Meow!"

def animal_sound(animal):
    print(f"{animal.name} says {animal.speak()}")

dog1 = Dog("Rex")
cat1 = Cat("Barsik")

animal_sound(dog1)
animal_sound(cat1)
```

### Результат.

![image](https://github.com/user-attachments/assets/d001b2ad-4367-4807-94d1-181a25589c9e)

### Выводы
В этом коде представлен полиморфизм, который позволяет разным классам, наследующим от Animal, иметь разные реализации методов, таких как speak(). Это позволяет использовать общий интерфейс для взаимодействия с объектами различных классов, что повышает гибкость и расширяемость кода.

## Общие выводы по теме
Данные задания позволили наглядно рассмотреть основные принципы объектно-ориентированного программирования (ООП) в Python — инкапсуляцию, наследование и полиморфизм, а также показали, как можно создавать гибкие и расширяемые структуры данных для моделирования различных объектов и их поведения.
