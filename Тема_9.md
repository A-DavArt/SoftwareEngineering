# Тема 9. Концепции и принципы ООП
Отчет по Теме №9 выполнил:
- Давтян Артём Артурович
- ИВТ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ |---------|---------|
| Задание 1 | +       | +       |
| Задание 2 | +       | +       |
| Задание 3 | +       | +       |
| Задание 4 | +       | +       |
| Задание 5 | +       | +       |
| Задание 6 | -       | +       |
| Задание 7 | -       | +       |
| Задание 8 | -       | +       |
| Задание 9 | -       | +       |
| Задание 10 | -       | +       |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

```python
class Ivan:
    __slots__ = ['name']

    def __init__(self, name):
        if name == 'Иван':
            self.name = f"Да, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"

person1 = Ivan('Алексей')
person2 = Ivan('Иван')
print(person1.name)
print(person2.name)
```
### Результат.

![image](https://github.com/user-attachments/assets/54b7572b-8a61-4b79-bea6-7ad3c0445344)

### Выводы
Данный код демонстрирует создание класса Ivan, который использует встроенный механизм проверки имени, чтобы определить, угадал ли пользователь имя "Иван". Класс находит применение в оригинальном подходе к взаимодействию с другими людьми, используя простые условия для ответа.

## Лабораторная работа №2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.

```python
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def composition(self):
        if self.ingredient:
            print(f"Мороженое с {self.ingredient}")
        else:
            print("Обычное мороженое")

icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```

### Результат.

![image](https://github.com/user-attachments/assets/172216fd-33fa-4ef8-aa8e-bd777cc6c7c6)

### Выводы
Данный код демонстрирует реализацию класса Icecream, который позволяет продавцу мороженого отслеживать наличие топпингов в мороженом и выводить соответствующее сообщение о его составе. 

## Лабораторная работа №3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают. Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.

```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):
        self._value = value

    def get_value(self):
        if hasattr(self, '_value'):
            return self._value
        else:
            return "value удалено"

    def del_value(self):
        del self._value

    value = property(get_value, set_value, del_value, "Свойство value")

obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```
### Результат.

![image](https://github.com/user-attachments/assets/1f306ee3-05bb-426d-acaf-2bef5b406e4d)

### Выводы
Данный код демонстрирует реализацию класса MyClass, который эффективно использует принципы инкапсуляции в объектно-ориентированном программировании, включая создание методов для доступа к атрибутам (геттеры и сеттеры) и деструктор для удаления атрибута.
  
## Лабораторная работа №4
### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.

```python
class Mammal:
    className = 'Mammal'

class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'

class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'

dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Dog is {cat.className}, but they say {cat.sounds}")
```
### Результат.

![image](https://github.com/user-attachments/assets/f7682a89-3644-4d2c-b994-9b79bb763d5b)

### Выводы
Данный код демонстрирует реализацию наследования в объектно-ориентированном программировании, показывая, как классы Dog и Cat наследуют свойства класса Mammal. 

## Лабораторная работа №5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.

```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")

class English:
    @staticmethod
    def greeting():
        print("Hello")

def greet(language):
    language.greeting()

ivan = Russian()
greet(ivan)
john = English()
greet(john)
```
### Результат.

![image](https://github.com/user-attachments/assets/a14d9bf4-f64f-47c4-bf21-f1cd62d0ac75)

### Выводы
Данный код демонстрирует принцип полиморфизма в объектно-ориентированном программировании, который позволяет использовать метод greeting в разных классах, чтобы выводить соответствующее приветствие в зависимости от языка. 

# Задание для самостоятельного выполнения:
## Садовник и помидоры.
### Классовая структура:
Есть **Помидор** со следующими характеристиками:
• Индекс
• Стадия созревания (стадии: отсутствует, цветение, зеленый, красный) Помидор может:
• Расти (переходить на следующую стадию созревания)
• Предоставлять информацию о своей зрелости

Есть **Куст с помидорами**, который:
• Содержит список томатов, которые на нем растут
А также может:
• Расти вместе с томатами
• Предоставлять информацию о зрелости всех томатов
• Предоставлять урожай

И также есть **Садовник**, который имеет:
• Имя
• Растение, за которым он ухаживает
Он может:
• Ухаживать за растением
• Собирать с него урожай

### Задание:
Класс **Tomato**:
1) Создайте класс Tomato
2) Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
3) Создайте метод __init__(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state (принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
4) Создайте метод grow(), который будет переводить томат на следующую стадию созревания
5) Создайте метод is_ripe(), который будет проверять, что томат созрел

Класс **TomatoBush**:
1) Создайте класс TomatoBush
2) Определите метод __init__(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes 3) Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
4) Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми.
5) Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая

Класс **Gardener**:
1) Создайте класс Gardener
2) Создайте метод __init__(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3) Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
4) Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5) Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству

## Самостоятельная работа №1
### Вызовите справку по садоводству

```python
class Tomato:
    states = ['absent', 'blooming', 'green', 'red']  # Стадии созревания

    def __init__(self, index):
        self._index = index  # Индекс (публичное свойство)
        self._state = self.states[0]  # Стадия созревания (первое значение из states)

    def grow(self):
        """Переход на следующую стадию созревания"""
        current_state_index = self.states.index(self._state)
        if current_state_index < len(self.states) - 1:
            self._state = self.states[current_state_index + 1]

    def is_ripe(self):
        """Проверка, что томат созрел"""
        return self._state == 'red'


class TomatoBush:
    def __init__(self, number_of_tomatoes):
        self.tomatoes = [Tomato(i) for i in range(number_of_tomatoes)]  # Список объектов Tomato

    def grow_all(self):
        """Вырастить все томаты"""
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        """Проверить, что все томаты спелые"""
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    def give_away_all(self):
        """Собрать урожай, очистив список томатов"""
        self.tomatoes.clear()


class Gardener:
    def __init__(self, name, plant):
        self.name = name  # Имя садаводника (публичное свойство)
        self._plant = plant  # Растение (объект класса TomatoBush)

    def work(self):
        """Уход за растением, чтобы оно становилось более зрелым"""
        self._plant.grow_all()

    def harvest(self):
        """Сбор урожая"""
        if self._plant.all_are_ripe():
            print(f"{self.name} собрал урожай.")
            self._plant.give_away_all()
        else:
            print(f"{self.name} не может собрать урожай, так как некоторые томаты еще не созрели.")

    @staticmethod
    def knowledge_base():
        """Вывод справки по садоводству"""
        print("Справка по садоводству:")
        print("1. Поливайте помидоры регулярно.")
        print("2. Обеспечьте достаточное количество света.")
        print("3. Следите за вредителями.")
        print("4. Собирать урожай следует, когда помидоры полностью красные.")


# Тест 1
Gardener.knowledge_base()  # Вызов справки по садоводству
```
### Результат.

![image](https://github.com/user-attachments/assets/8884f9c4-71fb-4da4-996d-a1d9e7d84121)

### Выводы
При вызове статического метода knowledge_base() была успешно выведена информация о полезных советах по уходу за помидорами. Это подтверждает, что метод работает корректно и предоставляет необходимые знания садоводам.
  
## Самостоятельная работа №2
### Создайте объекты классов TomatoBush и Gardener 

```python
class Tomato:
    states = ['absent', 'blooming', 'green', 'red']  # Стадии созревания

    def __init__(self, index):
        self._index = index  # Индекс (публичное свойство)
        self._state = self.states[0]  # Стадия созревания (первое значение из states)

    def grow(self):
        """Переход на следующую стадию созревания"""
        current_state_index = self.states.index(self._state)
        if current_state_index < len(self.states) - 1:
            self._state = self.states[current_state_index + 1]

    def is_ripe(self):
        """Проверка, что томат созрел"""
        return self._state == 'red'


class TomatoBush:
    def __init__(self, number_of_tomatoes):
        self.tomatoes = [Tomato(i) for i in range(number_of_tomatoes)]  # Список объектов Tomato

    def grow_all(self):
        """Вырастить все томаты"""
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        """Проверить, что все томаты спелые"""
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    def give_away_all(self):
        """Собрать урожай, очистив список томатов"""
        self.tomatoes.clear()


class Gardener:
    def __init__(self, name, plant):
        self.name = name  # Имя садаводника (публичное свойство)
        self._plant = plant  # Растение (объект класса TomatoBush)

    def work(self):
        """Уход за растением, чтобы оно становилось более зрелым"""
        self._plant.grow_all()

    def harvest(self):
        """Сбор урожая"""
        if self._plant.all_are_ripe():
            print(f"{self.name} собрал урожай.")
            self._plant.give_away_all()
        else:
            print(f"{self.name} не может собрать урожай, так как некоторые томаты еще не созрели.")

    @staticmethod
    def knowledge_base():
        """Вывод справки по садоводству"""
        print("Справка по садоводству:")
        print("1. Поливайте помидоры регулярно.")
        print("2. Обеспечьте достаточное количество света.")
        print("3. Следите за вредителями.")
        print("4. Собирать урожай следует, когда помидоры полностью красные.")


# Тест 1
Gardener.knowledge_base()  # Вызов справки по садоводству

# Тест 2
bush = TomatoBush(3)  # Создание объекта класса TomatoBush
gardener = Gardener("Алексей", bush)  # Создание объекта класса Gardener
```
### Результат.

![image](https://github.com/user-attachments/assets/7071355d-91f6-42c1-accd-1268ee92f201)

### Выводы
Были созданы экземпляры TomatoBush с тремя помидорами и Gardener с именем "Алексей". Код корректно инициализирует необходимые объекты, позволяя садовнику взаимодействовать с кустом помидоров.

## Самостоятельная работа №3
### Используя объект класса Gardener, поухаживайте за кустом с помидорами

```python
class Tomato:
    states = ['absent', 'blooming', 'green', 'red']  # Стадии созревания

    def __init__(self, index):
        self._index = index  # Индекс (публичное свойство)
        self._state = self.states[0]  # Стадия созревания (первое значение из states)

    def grow(self):
        """Переход на следующую стадию созревания"""
        current_state_index = self.states.index(self._state)
        if current_state_index < len(self.states) - 1:
            self._state = self.states[current_state_index + 1]

    def is_ripe(self):
        """Проверка, что томат созрел"""
        return self._state == 'red'


class TomatoBush:
    def __init__(self, number_of_tomatoes):
        self.tomatoes = [Tomato(i) for i in range(number_of_tomatoes)]  # Список объектов Tomato

    def grow_all(self):
        """Вырастить все томаты"""
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        """Проверить, что все томаты спелые"""
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    def give_away_all(self):
        """Собрать урожай, очистив список томатов"""
        self.tomatoes.clear()


class Gardener:
    def __init__(self, name, plant):
        self.name = name  # Имя садаводника (публичное свойство)
        self._plant = plant  # Растение (объект класса TomatoBush)

    def work(self):
        """Уход за растением, чтобы оно становилось более зрелым"""
        self._plant.grow_all()

    def harvest(self):
        """Сбор урожая"""
        if self._plant.all_are_ripe():
            print(f"{self.name} собрал урожай.")
            self._plant.give_away_all()
        else:
            print(f"{self.name} не может собрать урожай, так как некоторые томаты еще не созрели.")

    @staticmethod
    def knowledge_base():
        """Вывод справки по садоводству"""
        print("Справка по садоводству:")
        print("1. Поливайте помидоры регулярно.")
        print("2. Обеспечьте достаточное количество света.")
        print("3. Следите за вредителями.")
        print("4. Собирать урожай следует, когда помидоры полностью красные.")


# Тест 1
Gardener.knowledge_base()  # Вызов справки по садоводству

# Тест 2
bush = TomatoBush(3)  # Создание объекта класса TomatoBush
gardener = Gardener("Алексей", bush)  # Создание объекта класса Gardener

# Тест 3
gardener.work()  # Уход за кустом
```
### Результат.

![image](https://github.com/user-attachments/assets/9e44fac0-a9d9-4733-a4c0-62284a85048d)

### Выводы
Вызов метода work() у садовника приводит к росту всех помидоров на кусте. Это подтверждает, что метод grow_all() в классе TomatoBush работает должным образом и перемещает все помидоры на следующую стадию созревания.
  
## Самостоятельная работа №4
### Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними

```python
class Tomato:
    states = ['absent', 'blooming', 'green', 'red']  # Стадии созревания

    def __init__(self, index):
        self._index = index  # Индекс (публичное свойство)
        self._state = self.states[0]  # Стадия созревания (первое значение из states)

    def grow(self):
        """Переход на следующую стадию созревания"""
        current_state_index = self.states.index(self._state)
        if current_state_index < len(self.states) - 1:
            self._state = self.states[current_state_index + 1]

    def is_ripe(self):
        """Проверка, что томат созрел"""
        return self._state == 'red'


class TomatoBush:
    def __init__(self, number_of_tomatoes):
        self.tomatoes = [Tomato(i) for i in range(number_of_tomatoes)]  # Список объектов Tomato

    def grow_all(self):
        """Вырастить все томаты"""
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        """Проверить, что все томаты спелые"""
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    def give_away_all(self):
        """Собрать урожай, очистив список томатов"""
        self.tomatoes.clear()


class Gardener:
    def __init__(self, name, plant):
        self.name = name  # Имя садаводника (публичное свойство)
        self._plant = plant  # Растение (объект класса TomatoBush)

    def work(self):
        """Уход за растением, чтобы оно становилось более зрелым"""
        self._plant.grow_all()

    def harvest(self):
        """Сбор урожая"""
        if self._plant.all_are_ripe():
            print(f"{self.name} собрал урожай.")
            self._plant.give_away_all()
        else:
            print(f"{self.name} не может собрать урожай, так как некоторые томаты еще не созрели.")

    @staticmethod
    def knowledge_base():
        """Вывод справки по садоводству"""
        print("Справка по садоводству:")
        print("1. Поливайте помидоры регулярно.")
        print("2. Обеспечьте достаточное количество света.")
        print("3. Следите за вредителями.")
        print("4. Собирать урожай следует, когда помидоры полностью красные.")


# Тест 1
Gardener.knowledge_base()  # Вызов справки по садоводству

# Тест 2
bush = TomatoBush(3)  # Создание объекта класса TomatoBush
gardener = Gardener("Алексей", bush)  # Создание объекта класса Gardener

# Тест 3
gardener.work()  # Уход за кустом

# Тест 4
gardener.harvest()  # Попробуем собрать урожай, когда томаты еще не дозрели

# Увеличиваем созревание
gardener.work()
gardener.harvest()  # Попробуем собрать урожай снова

# Увеличиваем созревание до полного спелости
gardener.work()
gardener.work()
```
### Результат.

![image](https://github.com/user-attachments/assets/847e10ac-2802-44c5-bae2-3935bfe90491)

### Выводы
При вызове метода harvest() у садовника было выведено предупреждение о том, что не все помидоры созрели. Это показывает правильную работу метода all_are_ripe() в классе TomatoBush, который корректно определяет зрелость томатов.
  
## Самостоятельная работа №5
### Соберите урожай

```python
class Tomato:
    states = ['absent', 'blooming', 'green', 'red']  # Стадии созревания

    def __init__(self, index):
        self._index = index  # Индекс (публичное свойство)
        self._state = self.states[0]  # Стадия созревания (первое значение из states)

    def grow(self):
        """Переход на следующую стадию созревания"""
        current_state_index = self.states.index(self._state)
        if current_state_index < len(self.states) - 1:
            self._state = self.states[current_state_index + 1]

    def is_ripe(self):
        """Проверка, что томат созрел"""
        return self._state == 'red'


class TomatoBush:
    def __init__(self, number_of_tomatoes):
        self.tomatoes = [Tomato(i) for i in range(number_of_tomatoes)]  # Список объектов Tomato

    def grow_all(self):
        """Вырастить все томаты"""
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        """Проверить, что все томаты спелые"""
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    def give_away_all(self):
        """Собрать урожай, очистив список томатов"""
        self.tomatoes.clear()


class Gardener:
    def __init__(self, name, plant):
        self.name = name  # Имя садаводника (публичное свойство)
        self._plant = plant  # Растение (объект класса TomatoBush)

    def work(self):
        """Уход за растением, чтобы оно становилось более зрелым"""
        self._plant.grow_all()

    def harvest(self):
        """Сбор урожая"""
        if self._plant.all_are_ripe():
            print(f"{self.name} собрал урожай.")
            self._plant.give_away_all()
        else:
            print(f"{self.name} не может собрать урожай, так как некоторые томаты еще не созрели.")

    @staticmethod
    def knowledge_base():
        """Вывод справки по садоводству"""
        print("Справка по садоводству:")
        print("1. Поливайте помидоры регулярно.")
        print("2. Обеспечьте достаточное количество света.")
        print("3. Следите за вредителями.")
        print("4. Собирать урожай следует, когда помидоры полностью красные.")


# Тест 1
Gardener.knowledge_base()  # Вызов справки по садоводству

# Тест 2
bush = TomatoBush(3)  # Создание объекта класса TomatoBush
gardener = Gardener("Алексей", bush)  # Создание объекта класса Gardener

# Тест 3
gardener.work()  # Уход за кустом

# Тест 4
gardener.harvest()  # Попробуем собрать урожай, когда томаты еще не дозрели

# Увеличиваем созревание
gardener.work()
gardener.harvest()  # Попробуем собрать урожай снова

# Увеличиваем созревание до полного спелости
gardener.work()
gardener.work()

# Тест 5
gardener.harvest()  # Теперь должно получится собрать урожай
```

### Результат.

![image](https://github.com/user-attachments/assets/e417f266-2b5d-42f2-9527-f144e6b21fab)

### Выводы
После необходимости дополнительного ухода садовник успешно собрал урожай, так как все помидоры дозрели. Это подтверждает правильность работы методов harvest() и give_away_all() в классе TomatoBush, которые позволяют успешно собирать и очищать урожай.

## Общие выводы по теме
В ходе выполнения задач повторил ключевые принципы ООП: наследование, полиморфизм, инкапсуляция и абстракция. Эти принципы способствуют повторному использованию кода, повышают гибкость и упрощают управление данными, делая разработку более структурированной и эффективной. В результате, ООП облегчает создание и поддержку сложных программных систем.
